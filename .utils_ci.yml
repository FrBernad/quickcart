# Rerun: add/remove space

.create_and_export_service_images_variables:
  # GITLAB PROD IMAGE
  - export GITLAB_${SERVICE_NAME}_PROD_IMAGE=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:prod-${BUILD_ID}
  - echo "GITLAB_${SERVICE_NAME}_PROD_IMAGE=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:prod-${BUILD_ID}" >> context.env
  # GITLAB PROD IMAGE TAG LATEST
  - export "GITLAB_${SERVICE_NAME}_PROD_IMAGE_LATEST=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:prod-latest"
  - echo "GITLAB_${SERVICE_NAME}_PROD_IMAGE_LATEST=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:prod-latest" >> context.env
  # GITLAB TEST IMAGE
  - export GITLAB_${SERVICE_NAME}_TEST_IMAGE=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:test-${BUILD_ID}
  - echo "GITLAB_${SERVICE_NAME}_TEST_IMAGE=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:test-${BUILD_ID}" >> context.env
  # GITLAB TEST IMAGE LATEST
  - export GITLAB_${SERVICE_NAME}_TEST_IMAGE_LATEST=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:test-latest
  - echo "GITLAB_${SERVICE_NAME}_TEST_IMAGE_LATEST=${GITLAB_IMAGE_BASE}/${SERVICE_NAME}:test-latest" >> context.env
  # DOCKERHUB PROD IMAGE
  - export DOCKERHUB_${SERVICE_NAME}_PROD_IMAGE=${DOCKERHUB_IMAGE_BASE}/${SERVICE_NAME}:prod-${BUILD_ID}
  - echo "DOCKERHUB_${SERVICE_NAME}_PROD_IMAGE=${DOCKERHUB_IMAGE_BASE}/${SERVICE_NAME}:prod-${BUILD_ID}" >> context.env
  # DOCKERHUB PROD IMAGE TAG LATEST
  - export DOCKERHUB_${SERVICE_NAME}_PROD_IMAGE_LATEST=${DOCKERHUB_IMAGE_BASE}/${SERVICE_NAME}:prod-latest
  - echo "DOCKERHUB_${SERVICE_NAME}_PROD_IMAGE_LATEST=${DOCKERHUB_IMAGE_BASE}/${SERVICE_NAME}:prod-latest" >> context.env

.login_to_gitlab_registry:
  - docker login -u $CI_REGISTRY_USER --password $CI_JOB_TOKEN $CI_REGISTRY

# .setup_multi_os_build:
#   - docker buildx create --name multi-os-driver --driver docker-container --bootstrap --use

# .build_and_push_gitlab_prod_image:
#   - docker buildx build --platform linux/arm64,linux/amd64 -t ${GITLAB_PROD_IMAGE} -t ${GITLAB_PROD_IMAGE_LATEST} -f ${SERVICE_PATH}/Dockerfile.prod ${SERVICE_PATH} --push

# .build_and_push_gitlab_test_image:
#   - docker buildx build --platform linux/arm64,linux/amd64 -t ${GITLAB_TEST_IMAGE} -t ${GITLAB_TEST_IMAGE_LATEST} -f ${SERVICE_PATH}/Dockerfile.test --build-arg "BASE_IMAGE=$GITLAB_PROD_IMAGE" ${SERVICE_PATH} --push

.build_gitlab_prod_image:
  - docker build -t ${GITLAB_PROD_IMAGE} -f ${SERVICE_PATH}/Dockerfile.prod ${SERVICE_PATH}
  - docker tag ${GITLAB_PROD_IMAGE} ${GITLAB_PROD_IMAGE_LATEST}

.push_gitlab_prod_image:
  - docker push ${GITLAB_PROD_IMAGE}
  - docker push ${GITLAB_PROD_IMAGE_LATEST}

.build_gitlab_test_image:
  - docker build -t ${GITLAB_TEST_IMAGE} -f ${SERVICE_PATH}/Dockerfile.test --build-arg "BASE_IMAGE=$GITLAB_PROD_IMAGE" ${SERVICE_PATH}
  - docker tag ${GITLAB_TEST_IMAGE} ${GITLAB_TEST_IMAGE_LATEST}

.push_gitlab_test_image:
  - docker push ${GITLAB_TEST_IMAGE}
  - docker push ${GITLAB_TEST_IMAGE_LATEST}

.login_to_dockerhub_registry:
  - docker login -u $DOCKERHUB_USER --password $DOCKERHUB_PASS

.tag_and_push_dockerhub_prod_image:
  - docker tag $GITLAB_PROD_IMAGE $DOCKERHUB_PROD_IMAGE
  - docker tag $GITLAB_PROD_IMAGE $DOCKERHUB_PROD_IMAGE_LATEST
  - docker push $DOCKERHUB_PROD_IMAGE
  - docker push $DOCKERHUB_PROD_IMAGE_LATEST

.set_images_names:
  - eval "export GITLAB_PROD_IMAGE=\${GITLAB_${SERVICE_NAME}_PROD_IMAGE}"
  - eval "export GITLAB_PROD_IMAGE_LATEST=\${GITLAB_${SERVICE_NAME}_PROD_IMAGE_LATEST}"
  - eval "export GITLAB_TEST_IMAGE=\${GITLAB_${SERVICE_NAME}_TEST_IMAGE}"
  - eval "export GITLAB_TEST_IMAGE_LATEST=\${GITLAB_${SERVICE_NAME}_TEST_IMAGE_LATEST}"
  - eval "export DOCKERHUB_PROD_IMAGE=\${DOCKERHUB_${SERVICE_NAME}_PROD_IMAGE}"
  - eval "export DOCKERHUB_PROD_IMAGE_LATEST=\${DOCKERHUB_${SERVICE_NAME}_PROD_IMAGE_LATEST}"

.run_if_service_changes:
  rules:
    - if: $CI_COMMIT_BRANCH #default
      when: on_success #default
      changes:
        paths:
          - $SERVICE_PATH/**/*
          - .utils_ci.yml

.run_if_domain_changes:
  rules:
    - if: $CI_COMMIT_BRANCH #default
      when: on_success #default
      changes:
        paths:
          - $DOMAIN_PATH/**/*
          - .utils_ci.yml

.build_service:
  stage: build
  tags:
    - dev
  rules:
    - !reference [.run_if_service_changes, rules]
  before_script:
    - !reference [.create_and_export_service_images_variables]
    - !reference [.set_images_names]
  script:
    # - !reference [.setup_multi_os_build]
    # - !reference [.login_to_gitlab_registry]
    # - !reference [.build_and_push_gitlab_prod_image]
    # - !reference [.build_and_push_gitlab_test_image]
    - !reference [.build_gitlab_prod_image]
    - !reference [.build_gitlab_test_image]
    - !reference [.login_to_gitlab_registry]
    - !reference [.push_gitlab_prod_image]
    - !reference [.push_gitlab_test_image]
  artifacts:
    reports:
      dotenv: context.env
  needs:
    - job: preparation
      artifacts: true

.test_service:
  stage: test
  tags:
    - dev
  variables:
    ENV: "test"
  rules:
    - !reference [.run_if_service_changes, rules]
  before_script:
    - !reference [.set_images_names]
  script:
    - !reference [.login_to_gitlab_registry]
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.test --profile ${SERVICE_NAME} stop
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.test --profile ${SERVICE_NAME} rm
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.test --profile ${SERVICE_NAME} pull
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.test --profile ${SERVICE_NAME} up --abort-on-container-exit
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.test --profile ${SERVICE_NAME} rm

    - docker cp ${SERVICE_NAME}_${ENV}:/usr/app/coverage.xml .
    - docker cp ${SERVICE_NAME}_${ENV}:/usr/app/report.xml .
  artifacts:
    when: always
    paths:
      - coverage.xml
      - report.xml
    reports:
      junit: report.xml

.deploy_qa:
  stage: qa
  tags:
    - dev
  variables:
    ENV: "qa"
  rules:
    - !reference [.run_if_service_changes, rules]
  script:
    - !reference [.login_to_gitlab_registry]
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.qa --profile ${SERVICE_NAME} pull
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.qa --profile ${SERVICE_NAME} up -d

.deliver_dockerhub:
  stage: deliver
  tags:
    - dev
  rules:
    - !reference [.run_if_service_changes, rules]
  before_script:
    - !reference [.set_images_names]
  script:
    - !reference [.login_to_gitlab_registry]
    - !reference [.login_to_dockerhub_registry]
    - !reference [.tag_and_push_dockerhub_prod_image]

.deploy_prod:
  stage: deploy
  tags:
    - prod
  rules:
    - !reference [.run_if_domain_changes, rules]
  script:
    - !reference [.login_to_dockerhub_registry]
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.prod --profile all pull
    - docker compose -f ${DOMAIN_PATH}/docker-compose.yml --env-file ${DOMAIN_PATH}/.env_files/.env.prod --profile all up -d
